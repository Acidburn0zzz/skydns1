// Copyright (c) 2013 Erik St. Martin, Brian Ketelsen. All rights reserved.
// Use of this source code is governed by The MIT License (MIT) that can be
// found in the LICENSE file.

package server

import (
	"crypto/sha1"
	"github.com/miekg/dns"
	"log"
	"os"
	"sync"
	"time"
)

const origTTL uint32 = 3600
var cache *sigCache = newCache()

// ParseKeyFile read a DNSSEC keyfile as generated by dnssec-keygen or other
// utilities. It add ".key" for the public key and ".private" for the private
// key.
func ParseKeyFile(file string) (*dns.DNSKEY, dns.PrivateKey, error) {
	f, e := os.Open(file + ".key")
	if e != nil {
		return nil, nil, e
	}
	k, e := dns.ReadRR(f, file+".key")
	if e != nil {
		return nil, nil, e
	}
	f, e = os.Open(file + ".private")
	if e != nil {
		return nil, nil, e
	}
	p, e := k.(*dns.DNSKEY).ReadPrivateKey(f, file+".private")
	if e != nil {
		return nil, nil, e
	}
	return k.(*dns.DNSKEY), p, nil
}

// sign signs a message m, it takes care of negative or nodata responses as
// well by synthesising NSEC records. It will also cache the signatures, using
// a hash of the signed data as a key as well as the generated NSEC records.
// We also fake the origin TTL in the signature, because we don't want to 
// throw away signatures when services decide to have longer TTL.
func (s *Server) sign(m *dns.Msg, bufsize uint16) {
	now := time.Now()
	incep := uint32(now.Add(-2 * time.Hour).Unix()) // 2 hours, be sure to catch daylight saving time and such
	expir := uint32(now.Add(7 * 24 * time.Hour).Unix())

	for _, r := range rrSets(m.Answer) {
		sig := new(dns.RRSIG)
		sig.Hdr.Ttl = r[0].Header().Ttl
		sig.OrigTtl = origTTL
		sig.Algorithm = s.Dnskey.Algorithm
		sig.KeyTag = s.KeyTag
		sig.Inception = incep
		sig.Expiration = expir
		sig.SignerName = s.Dnskey.Hdr.Name
		if e := sig.Sign(s.Privkey, r); e != nil {
			log.Printf("Failed to sign: %s\n", e.Error())
			continue
		}
		m.Answer = append(m.Answer, sig)
	}
	for _, r := range rrSets(m.Ns) {
		sig := new(dns.RRSIG)
		sig.Hdr.Ttl = origTTL
		sig.OrigTtl = origTTL
		sig.Algorithm = s.Dnskey.Algorithm
		sig.KeyTag = s.KeyTag
		sig.Inception = incep
		sig.Expiration = expir
		sig.SignerName = s.Dnskey.Hdr.Name
		if e := sig.Sign(s.Privkey, r); e != nil {
			log.Printf("Failed to sign: %s\n", e.Error())
			continue
		}
		m.Ns = append(m.Ns, sig)
	}
	// TODO(miek): Forget the additional section for now
	if bufsize >= 512 || bufsize <= 4096 {
		m.Truncated = m.Len() > int(bufsize)
	}
	o := new(dns.OPT)
	o.Hdr.Name = "."
	o.Hdr.Rrtype = dns.TypeOPT
	o.SetDo()
	o.SetUDPSize(4096)
	m.Extra = append(m.Extra, o)
	return
}

type rrset struct {
	qname string
	qclass uint16
	qtype uint16
}

func rrSets(rrs []dns.RR) map[rrset][]dns.RR {
	m := make(map[rrset][]dns.RR)
	for _, r := range rrs {
		if s, ok := m[rrset{r.Header().Name, r.Header().Class, r.Header().Rrtype}]; ok {
			s = append(s, r)
		} else {
			s := make([]dns.RR, 1, 3)
			s[0] = r
			m[rrset{r.Header().Name, r.Header().Class, r.Header().Rrtype}] = s
		}
	}
	if len(m) > 0 {
		return m
	}
	return nil
}

type sigCache struct {
	rw sync.RWMutex
	m map[string]*dns.RRSIG
}

func newCache() *sigCache {
	c := new(sigCache)
	c.m = make(map[string]*dns.RRSIG)
	return c
}

func (c *sigCache) Remove(s string) {
	// does not need a lock
}

func (c *sigCache) Insert(s string, r *dns.RRSIG) {

}

func (c *sigCache) Search(s string) *dns.RRSIG {
	return nil
}

// makeKey uses the name, type and rdata, which is serialized
// and then hashed.
func (c *sigCache) makeKey(rrs []dns.RR) string {
	h := sha1.New()
	i := []byte(rrs[0].Header().Name)
	i = append(i, byte(rrs[0].Header().Rrtype >> 8))
	i = append(i, byte(rrs[0].Header().Rrtype ))
	for _, r := range rrs {
		switch r.Header().Rrtype { // we only do a few type, serialize does:w



		}
	}
	return string(h.Sum(i))
}
